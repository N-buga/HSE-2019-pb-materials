# Параллелимся

## Задачи

Раз у нас параллельное программирование, то будем параллелиться. Выбирайте свой уровень понимания теории с лекции и работаем.

### Легкий уровень.

В течение работы не забывайте про valgrind и fsanitizer :)

1. Возьмите файлик `01_flags.cpp`. Скомпилируйте и запустите.
2. Сделайте так, чтобы значения флага выводились последовательно. (Т.е. чтобы каждое изменение ловил consumer)
3. Избавьтесь от всех ошибок параллельного программирования :)
4. Избавьтесь от активного ожидания.

### Сложный уровень.

У вас есть очень сложная с точки зрения вычисления функция. В общем случае это может быть хоть скачивание данных из интернета. Однако, вы не хотите, чтобы ваша программа зависала, пока вы ждете завершения той функции. Вы хотите дать возможность смотреть на прогресс или просто заниматься своими делами в приложении.

Именно это хочется проэмулировать данной задачей. 

В файле `02_show_and_compute.cpp` лежит сложно вычислимая функция, которая как-то меняет значение переменной.

Пользователь может вводить две команды: `show` и `next`. Первая выводит на экран текущее значение переменной. `next` запускает вычисление функции от значения переменной и затем изменяет его. Вы хотите, чтобы `show` работало в любой момент, а вызов `next` позволял и дальше писать команды. Например, если вы вызвали `next`, а затем без видимой задержки вызвали `show`, то должно вывестись какое-то корректное значение (если успело досчитаться, то новое, если не успело, то старое). Если вы вызовите `next`, пока функция еще не досчитала, должно вывестись сообщение об этом и старое значение переменной.

1. Впишите код так, чтобы работало show и next. Если предыдущие вычисления не закончились, а вы вызываете next, то надо сообщить пользователю, что идут старые вычисления.
2. Попробуйте поймать spurious wakeup.
3. Попробуйте избавиться от него.
4. Вообще, хотелось бы, чтобы задачи не терялись и когда вызывается `next`, а вычисления еще идут, это запоминалось и запускалось после. Подумайте, как это сделать и сделайте.

### Тулзы
* Компилировать с ключами `-g -fsanitize=thread` для pthread sanitiser
* Запустить на исполняемом файле `valgrind --tool=helgrind` для valgrind
* `clang-format` для проверки форматирования.

